var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/utils.ts
var toString = Object.prototype.toString;
function escapeRegExp(val) {
  return val.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isString(val) {
  return typeof val === "string";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]")
    return false;
  const prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function mapKeys(object, converter) {
  return Object.entries(object).reduce((result, entry) => {
    const [key, value] = entry;
    if (isString(key))
      result[converter(value, key)] = value;
    return result;
  }, {});
}
function mapValues(object, converter) {
  return Object.entries(object).reduce((result, entry) => {
    const [key, value] = entry;
    result[key] = converter(value, key);
    return result;
  }, {});
}
function camelCase(key) {
  return key.replace(/([-_][a-z])/ig, ($1) => $1.toUpperCase().replace("-", "").replace("_", ""));
}
function snakeCase(key) {
  return key.replace(/([a-z\d])([A-Z])/g, "$1_$2").toLowerCase();
}
function convertKeys(object, keyConverter) {
  if (isPlainObject(object))
    return mapKeys(object, (_value, key) => keyConverter(key));
  else
    return object;
}
function deepConvertKeys(object, keyConverter) {
  if (Array.isArray(object))
    return object.map((item) => deepConvertKeys(item, keyConverter));
  if (isPlainObject(object))
    return mapValues(convertKeys(object, keyConverter), (value) => deepConvertKeys(value, keyConverter));
  return object;
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined")
    return;
  if (!isObject(obj))
    obj = [obj];
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++)
      fn(obj[i], i, obj);
  } else {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key))
        fn(obj[key], key, obj);
    }
  }
}

// src/urls.ts
var REQUIRED_PARAMETER = /:[^\W\d]+/g;
var OPTIONAL_PARAMETER = /\(\/:[^\W\d]+\)/g;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function serializeQuery(params) {
  const parts = [];
  forEach(params, (val, key) => {
    if (val === null || typeof val === "undefined")
      return;
    if (Array.isArray(val))
      key = `${key}[]`;
    else
      val = [val];
    forEach(val, (v) => {
      if (isDate(v))
        v = v.toISOString();
      else if (isObject(v))
        v = JSON.stringify(v);
      parts.push(`${encode(key)}=${encode(v)}`);
    });
  });
  return parts.join("&");
}
function buildURL(url, params) {
  if (!params)
    return url;
  const queryStr = isURLSearchParams(params) ? params.toString() : serializeQuery(deepConvertKeys(params, snakeCase));
  if (queryStr) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1)
      url = url.slice(0, hashmarkIndex);
    url += `${url.includes("?") ? "&" : "?"}${queryStr}`;
  }
  return url;
}
function interpolateUrl(template, params) {
  let value = template.toString();
  Object.entries(params).forEach(([paramName, paramValue]) => {
    paramName = snakeCase(paramName);
    value = value.replace(new RegExp(escapeRegExp(`(/:${paramName})`), "g"), `/${paramValue}`).replace(new RegExp(`:${escapeRegExp(paramName)}(\\/|\\.|\\(|$)`, "g"), `${paramValue}$1`);
  });
  value = value.replace(OPTIONAL_PARAMETER, "");
  const missingParams = value.match(REQUIRED_PARAMETER);
  if (missingParams) {
    const missing = missingParams.join(", ");
    const provided = params && Object.keys(params).join(", ") || "none.";
    throw new TypeError(`Missing URL Parameter ${missing} for ${template}. Params provided: ${provided}`);
  }
  return value;
}
function formatUrl(urlTemplate, _a = {}) {
  var _b = _a, { query } = _b, params = __objRest(_b, ["query"]);
  return buildURL(interpolateUrl(urlTemplate, params), query);
}
export {
  camelCase,
  convertKeys,
  deepConvertKeys,
  escapeRegExp,
  forEach,
  formatUrl,
  interpolateUrl,
  isDate,
  isObject,
  isPlainObject,
  isString,
  isURLSearchParams,
  mapKeys,
  mapValues,
  snakeCase
};
