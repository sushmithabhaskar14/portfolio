import { UrlOptions } from '@js-from-routes/core';

declare type Method = 'GET' | 'get' | 'DELETE' | 'delete' | 'HEAD' | 'head' | 'OPTIONS' | 'options' | 'POST' | 'post' | 'PUT' | 'put' | 'PATCH' | 'patch' | 'PURGE' | 'purge' | 'LINK' | 'link' | 'UNLINK' | 'unlink';
declare type ResponseAs = 'response' | 'json' | 'text' | 'blob' | 'formData' | 'arrayBuffer';
/**
 * Options for `fetch` that can be customized.
 */
declare type BaseFetchOptions = Omit<RequestInit, 'method' | 'body'>;
/**
 * Passed to the `fetch` function when performing a request.
 */
interface FetchOptions extends BaseFetchOptions {
    url: string;
    method: Method;
    data: any;
    responseAs: ResponseAs;
    headers: Record<string, string>;
}
/**
 *
 */
interface RequestOptions {
    /**
     * The query string parameters to interpolate in the URL.
     */
    params?: UrlOptions;
    /**
     * The body of the request, should be a plain Object.
     */
    data?: any;
    /**
     * The function used to transform the data received from the server.
     * @default camelizeKeys
     */
    deserializeData?: (data: any) => any;
    /**
     * Use a different function to make the request.
     * @default Config.fetch
     */
    fetch: (options: FetchOptions) => Promise<Response>;
    /**
     * Additional options for the `fetch` function.
     */
    fetchOptions: BaseFetchOptions;
    /**
     * Override the default method for the path helper.
     */
    method: Method;
    /**
     * The function used to convert the data before sending it to the server.
     * @default snakeCaseKeys
     */
    serializeData?: (data: any) => any;
    /**
     * What kind of response is expected. Defaults to `json`. `response` will
     * return the raw response from `fetch`.
     * @default 'json'
     */
    responseAs?: ResponseAs;
    /**
     * Headers to send in the request.
     */
    headers?: Record<string, string>;
}
declare type Options = RequestOptions | UrlOptions;
interface HeaderOptions {
    method: Method;
    url: string;
    options: Options;
}
interface PathHelper {
    <T = any>(options?: Options): Promise<T>;
    path: (params?: UrlOptions) => string;
    pathTemplate: string;
    httpMethod: Method;
}

/**
 * Defines a path helper that can make a request or interpolate a URL path.
 *
 * @param {Method} method  An HTTP method
 * @param {string} pathTemplate The path with params placeholders (if any).
 */
declare function definePathHelper(method: Method, pathTemplate: string): PathHelper;
/**
 * Formats a url, replacing segments like /:id/ with the parameter of that name.
 * @param {string} urlTemplate A template URL with placeholders for params
 * @param {Query}  query       Query parameters to append to the URL
 * @param {Params} params      Parameters to interpolateUrl in the URL placeholders
 * @return {string} The interpolated URL with the provided query params (if any)
 * @example
 *   formatUrl('/users/:id', { id: '5' }) returns '/users/5'
 *   formatUrl('/users', { query: { id: '5' } }) returns '/users?id=5'
 */
declare function formatUrl(urlTemplate: string, options?: UrlOptions): string;
/**
 * Makes an AJAX request to the API server.
 * @param  {Method}  method HTTP request method
 * @param  {string}  url    May be a template with param placeholders
 * @param  {Options} options Can optionally pass params as a shorthand
 * @return {Promise} The result of the request
 */
declare function request(_method: Method, url: string, options?: Options): Promise<any>;

interface ResponseError extends Error {
    body?: any;
    response?: Response;
}
/**
 * You may customize these options to configure how requests are sent.
 */
declare const Config: {
    /**
     * An optional base URL when the API is hosted on a different domain.
     */
    baseUrl: string;
    /**
     * The function used to transform the data received from the server.
     * @default camelizeKeys
     */
    deserializeData: (data: any) => any;
    /**
     * The function used to convert the data before sending it to the server.
     * @default snakeCaseKeys
     */
    serializeData: (data: any) => any;
    /**
     * The CSRF token to use in the requests.
     * @see Config.getCSRFToken
     */
    csrfToken: string;
    /**
     * Strategy to obtain the CSRF token.
     */
    getCSRFToken(): string | undefined;
    /**
     * Allows to replace the default strategy to use Axios or other libraries.
     */
    fetch(args: FetchOptions): Promise<Response>;
    /**
     * Default headers to be sent in the request, JSON is used as the default MIME.
     */
    headers(_requestInfo: HeaderOptions): {
        'X-CSRF-Token'?: string | undefined;
        Accept: string;
        'Content-Type': string;
    };
    /**
     * Allows changes to the request data before it is sent to the server.
     */
    modifyRequest(request: FetchOptions): FetchOptions | undefined;
    /**
     * Allows to intercept errors globally.
     */
    onResponseError(error: ResponseError): Promise<never>;
    /**
     * Unwrap the response based on the `responseAs` value in the request.
     * @returns json, text, or the response.
     */
    unwrapResponse(response: Response, responseAs: ResponseAs): Promise<any>;
    /**
     * Similar to unwrapResponse, but when a request fails.
     */
    unwrapResponseError(response: Response, responseAs: ResponseAs): Promise<ResponseError>;
    /**
     * Convenience hook to extract headers from the response.
     */
    withResponse(response: Response): void;
};

export { BaseFetchOptions, Config, FetchOptions, HeaderOptions, Method, Options, PathHelper, RequestOptions, ResponseAs, ResponseError, definePathHelper, formatUrl, request };
