declare type Query = Record<string, any>;
declare type Params = Record<string, any>;
declare type UrlOptions = {
    query?: Query;
    [key: string]: any;
};
/**
 * Replaces any placeholder in the string with the provided parameters.
 *
 * @param  {string} template The URL template with `:placeholders`
 * @param  {Params} params   Parameters to inject in the placeholders
 * @return {string} The resulting URL with replaced placeholders
 */
declare function interpolateUrl(template: string, params: Params): string;
/**
 * Formats a url, replacing segments like /:id/ with the parameter of that name.
 * @param {string} urlTemplate A template URL with placeholders for params
 * @param {Query}  query       Query parameters to append to the URL
 * @param {Params} params      Parameters to interpolateUrl in the URL placeholders
 * @return {string} The interpolated URL with the provided query params (if any)
 * @example
 *   formatUrl('/users/:id', { id: '5' }) returns '/users/5'
 *   formatUrl('/users', { query: { id: '5' } }) returns '/users?id=5'
 */
declare function formatUrl(urlTemplate: string, { query, ...params }?: UrlOptions): string;

declare type KeyConverter = (key: string) => string;
declare type Dictionary = Record<string, any>;
/**
 * Escapes the specified string to be safely injected in a Regexp expression.
 */
declare function escapeRegExp(val: string): string;
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
declare function isURLSearchParams(val: any): val is URLSearchParams;
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
declare function isDate(val: unknown): val is Date;
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
declare function isString(val: unknown): val is string;
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
declare function isPlainObject(val: unknown): val is Dictionary;
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
declare function isObject(val: unknown): val is object;
/**
 * Creates an object with the same values as `object` and keys generated by
 * running each property of `object` through `converter`.
 * The converter is invoked with two arguments: (value, key).
 *
 * @param {Object} object The object to iterate over.
 * @param {Function} converter The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 */
declare function mapKeys(object: Dictionary, converter: (value: any, key: string) => any): Dictionary;
/**
 * Creates an object with the same keys as `object` and values generated
 * by running each property of `object` through `converter`.
 * The converter is invoked with two arguments: (value, key).
 *
 * @param {Object} object The object to iterate over.
 * @param {Function} converter The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 */
declare function mapValues(object: Dictionary, converter: (value: any, key?: string) => any): Dictionary;
/**
 * Returns the camelCased version of a snake_cased string.
 * @example camelCase('build_output_dir') === 'buildOutputDir'
 */
declare function camelCase(key: string): string;
/**
 * Returns the snake_cased version of a camelCased string.
 * @example snakeCase('buildOutputDir') === 'build_output_dir'
 */
declare function snakeCase(key: string): string;
/**
 * Returns a new object with converted key names, if `object` is a plain object.
 */
declare function convertKeys<T>(object: T, keyConverter: KeyConverter): T | Dictionary;
/**
 * Recursively converts all keys in nested objects.
 *
 * @params {Object|Array} object The value to recursively scan
 * @params {Function} keyConverter A function to transform the keys
 */
declare function deepConvertKeys<T>(object: T, keyConverter: KeyConverter): T | Dictionary;
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
declare function forEach(obj: any, fn: (value: any, keyOrIndex: any, obj: Dictionary | any[]) => void): void;

export { Dictionary, KeyConverter, Params, Query, UrlOptions, camelCase, convertKeys, deepConvertKeys, escapeRegExp, forEach, formatUrl, interpolateUrl, isDate, isObject, isPlainObject, isString, isURLSearchParams, mapKeys, mapValues, snakeCase };
